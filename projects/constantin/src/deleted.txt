appendNewCubeTohalfedgeMesh(cubeIndices:number[]){
        /*for(let i=0;i<cubeIndices.length;i+=3){
            const a=cubeIndices[i+0];
            const b=cubeIndices[i+1];
            const c=cubeIndices[i+2];
            const e = `${a}-${b}-${c}`;
            if(!this.completelyDiscardedTriangleIndices.has(e)){
                // we have not yet removed this triangle
                if (!this.triangleIndicesMap.has(e)) {
                    this.triangleIndicesMap.set(e, [a, b,c])
                    this.completelyDiscardedTriangleIndices.set(e,[a,b,c]);
                    this.mappedTriangleIndices.push(a);
                    this.mappedTriangleIndices.push(b);
                    this.mappedTriangleIndices.push(c);
                }else{
                    console.log("Duplicate removed\n");
                }
            }else{
                console.log("Completely removed\n");
            }
        }*/
        /*for(let i=0;i<cubeIndices.length;i++){
            this.mappedTriangleIndices.push(cubeIndices[i]);
        }*/
        for(let i=0;i<cubeIndices.length;i++){
            this.allIndicesArray.push(cubeIndices[i]);
        }
    
        for(let i=0;i<cubeIndices.length;i+=6){
            // These vertices form a face
            const a1=cubeIndices[i+0];
            const b1=cubeIndices[i+1];
            const c1=cubeIndices[i+2];

            const a2=cubeIndices[i+3];
            const b2=cubeIndices[i+4];
            const c2=cubeIndices[i+5];

            //if(a1!=a2){
            //    console.log("Argh");
            //}
            //if(c1!=c2){
                //console.log("Argh2:"+a1+","+b1+","+c1+" |"+a2+","+b2+","+c2+" |");
            //}

            const e = `${a1}-${b1}-${c1}-${a2}-${b2}-${c2}`;
            //console.log("Hash:"+e);

            if(!this.completelyDiscardedTriangleIndices.has(e)){
                // we have not yet removed this triangle
                if (!this.triangleIndicesMap.has(e)) {
                    this.triangleIndicesMap.set(e, [a1, b1,c1])
                    this.completelyDiscardedTriangleIndices.set(e,[a1,b1,c1]);
                    this.mappedTriangleIndices.push(a1);
                    this.mappedTriangleIndices.push(b1);
                    this.mappedTriangleIndices.push(c1);
                    //
                    this.mappedTriangleIndices.push(a2);
                    this.mappedTriangleIndices.push(b2);
                    this.mappedTriangleIndices.push(c2);
                }else{
                    console.log("Duplicate removed\n");
                }
            }else{
                //console.log("Completely removed\n");
                this.completelyRemovedIndices.push(a1);
                this.completelyRemovedIndices.push(b1);
                this.completelyRemovedIndices.push(c1);
                //
                this.completelyRemovedIndices.push(a2);
                this.completelyRemovedIndices.push(b2);
                this.completelyRemovedIndices.push(c2);
            }
        }
    }




let bigBuffVertices=new Array<THREE.Vector3>();
let bigBuffIndices=new Array<number>();
//
const [vertices,indices]= alignedCube.createVerticesIndices();
const idxOffset=bigBuffVertices.length;
bigBuffVertices=bigBuffVertices.concat(vertices);
bigBuffIndices=bigBuffIndices.concat(Helper.addOffsetToIndices(idxOffset,indices));    

//let [x1Vert,x1Ind]=Helper.removeIsolatedVertices(Helper.convertToThreJs2(xBuffVertices),this.yIndices);
//this.bigTestMesh=Helper.createWireframeMeshFromVertsIndices(Helper.convertVertices(x1Vert),x1Ind,new THREE.Color('red'));

//this.bigTestMesh=Helper.createMeshFromVertsIndices(Helper.convertVertices(bigBuffVertices),bigBuffIndices,new THREE.Color('red'));
//this.bigTestMesh=Helper.createMeshFromVertsIndices(xBuffVertices,remaining,new THREE.Color('orange'));

//let [x1Vert,x1Ind]=Helper.removeIsolatedVertices(Helper.convertToThreJs2(xBuffVertices),this.yIndices);

//this.bigTestMesh=AlignedCube.createWireframeMeshFromVertsIndices(AlignedCube.convertVertices(this.verticesBuff),this.indicesBuff);
//this.bigTestMesh=Helper.createWireframeMeshFromVertsIndices(xBuffVertices,this.yIndices,new THREE.Color('red'));
//scene.add(Helper.createWireframeMeshFromVertsIndices(xBuffVertices,this.yIndices,new THREE.Color('green')));
//scene.add(Helper.createWireframeMeshFromVertsIndices(this.yVertices,this.yIndices,new THREE.Color('green'),3));
//this.bigTestMesh=AlignedCube.createWireframeMeshFromVertsIndices(xBuffVertices,this.indicesBuff);
//scene.add(this.bigTestMesh!);

//this.createdHalfedgeMesh=new HalfedgeMesh(remaining,Vector.convArray3(xBuffVertices));
//this.createdHalfedgeMesh=new HalfedgeMesh(xBuffIndices,Vector.convArray3(xBuffVertices));
//this.createdHalfedgeMesh=new HalfedgeMesh(bigBuffIndices,Vector.convArray(bigBuffVertices));

//remaining=AlignedCube.fixOrder(remaining);

  let argh=new Array<number>();
        let takeSome=3*500;
        takeSome = takeSome <= remaining.length ? takeSome : remaining.length;
        for(let i=0;i<takeSome;i++){
            argh.push(remaining[i]);
        }


//this.internal.mesh3js!.geometry.computeBoundingBox();
    //let box = new Box3();
    //box.copy(this.internal.mesh3js!.geometry.boundingBox!);
    let box = new Box3()
    const helper = new Box3Helper(box);
    //this.scene.add(helper);
    Helper.debugBoundingBox(box);
    //Voxelizer.addCubeSizeOne(this.scene);        


 static fixOrder(indices:number[]):number[]{
        let ret=new Array<number>();
        for(let i=0;i<indices.length;i+=3){
            const a=indices[i+0];
            const b=indices[i+1];
            const c=indices[i+2];
            const [a1,b1,c1]=Helper.sortAscending(a,b,c);
            if(a!=a1 || b!=b1 || c!=c1){
                console.log("not sorted"+a+","+b+","+c+"");
            }else{
                console.log("sorted"+a+","+b+","+c+"");
            }
            ret.push(a1);
            ret.push(b1);
            ret.push(c1);
        }
        return ret;
    }

 createMesh2(scene:THREE.Scene):THREE.LineSegments{
        let [vertices,indices]= this.createVerticesIndices();
        //scene.add(this.createMeshFromVertsIndices(scene,vertices,indices));
        //scene.add(this.createWireframeMeshFromVertsIndices(scene,vertices,indices));
        //this.testAddSimpleFace(scene);
        return Helper.createWireframeMeshFromVertsIndices(Helper.convertVertices(vertices),indices);
    }      



// https://fileadmin.cs.lth.se/cs/Personal/Tomas_Akenine-Moller/code/tribox.txt

export class XVector3 {
  numbers: number[];
 
  constructor(x?: number, y?: number, z?: number) {
    this.numbers =new Array<number>(3);
    this.numbers[0] = x || 0;
    this.numbers[1] = y || 0;
    this.numbers[2] = z || 0;
  }

  public static CROSS(v1:number[],v2:number[]):number[]{
    let dest=new Array<number>(3);
    dest[0]=v1[1]*v2[2]-v1[2]*v2[1];
    dest[1]=v1[2]*v2[0]-v1[0]*v2[2];
    dest[2]=v1[0]*v2[1]-v1[1]*v2[0];
    return dest;
  }

  public static DOT(v1:number[],v2:number[]):number{
    return (v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2]);
  }

  public static SUB(v1:number[],v2:number[]):number[]{
    let dest=new Array<number>(3);
    dest[0]=v1[0]-v2[0];
    dest[1]=v1[1]-v2[1];
    dest[2]=v1[2]-v2[2];
    return dest;
  }
  public static FINDMINMAX(x0:number,x1:number,x2:number,min:number,max:number){
    min = max = x0;
    if(x1<min) min=x1;
    if(x1>max) max=x1;
    if(x2<min) min=x2;
    if(x2>max) max=x2;
  }

  /*======================== X-tests ========================*/
/*  public static  AXISTEST_X01(a:any, b:any, fa:any, fb:any){			  
p0 = a*v0[Y] - b*v0[Z];			       	   
p2 = a*v2[Y] - b*v2[Z];			       	   \
      if(p0<p2) {min=p0; max=p2;} else {min=p2; max=p0;} 
rad = fa * boxhalfsize[Y] + fb * boxhalfsize[Z];   
if(min>rad || max<-rad) return 0;
  }*/

  public static planeBoxOverlap(normal:number[],d:number,maxbox:number[]):number{
    let vmin=new Array<number>(3);
    let vmax=new Array<number>(3);
    for(let q=0;q<=2;q++){
      if(normal[q]>0.0) {
        vmin[q]=-maxbox[q];
        vmax[q]=maxbox[q];
      }else{
        vmin[q]=maxbox[q];
        vmax[q]=-maxbox[q];
      }
    }
    if(XVector3.DOT(normal,vmin)+d>0.0) return 0;
    if(XVector3.DOT(normal,vmax)+d>=0.0) return 1;
    return 0;
  }

  

  public static checkTriangleCube():boolean{
    let triangle=new THREE.Triangle();
    let cube = new THREE.Box3;
    return cube.intersectsTriangle(triangle);
  }


}    

static testAddSimpleFace(scene:THREE.Scene){
        // create a simple square shape.
        const vertices = [
            -1.0, -1.0,  1.0,
            1.0, -1.0,  1.0,
            1.0,  1.0,  1.0,
           -1.0,  1.0,  1.0,
        ] ;
        const indices=[
            0,1,2,0,2,3
        ];
        scene.add(Helper.createMeshFromVertsIndices(vertices,indices));
        scene.add(Helper.createWireframeMeshFromVertsIndices(vertices,indices));
    }


static removeIsolatedVertices(vertices:THREE.Vector3[],indices:number[]):[THREE.Vector3[],number[]]{
        // mark the vertices that are actually used by indices
        let used=new Array<boolean>(vertices.length);
        used.fill(false);
        for(let i=0;i<indices.length;i++){
            used[indices[i]]=true;
        }
        let unused=new Array<number>();
        for(let i=0;i<used.length;i++){
            if(!used[i]){
                unused.push(i);
                //console.log("Vert:"+i+" is unused\n");
            }else{
                //console.log("Vert:"+i+" is used\n");
            }
        }
        let verticesRet=new Array<THREE.Vector3>();
        for(let i=0;i<vertices.length;i++){
            if(used[i]){
                verticesRet.push(vertices[i]);
            }
        }
        //verticesRet=verticesRet.concat(vertices);
        let indicesRet=new Array<number>();
        indicesRet=indicesRet.concat(indices);

        for(let i=0;i<unused.length;i++){
            const unu=unused[i];
            for(let j=0;j<indicesRet.length;j++){
                if(indicesRet[j]>unu){
                    indicesRet[j]=indicesRet[j]-1;
                }
            }
            /*for(let j=i+1;j<unused.length;j++){
                if(unused[j]>unu){
                    unused[j]=unused[j]-1;
                }
            }*/
        }
        return [verticesRet,indicesRet];
    }

/*let faceIndices=[
            // front
            [x,y,z],
            [x+1,y,z],
            [x+1,y+1,z],
            [x,y,z],
            [x+1,y+1,z],
            [x,y+1,z],
            // back
            [x,y,z+1],
            [x+1,y,z+1],
            [x+1,y+1,z+1],
            [x,y,z+1],
            [x+1,y+1,z+1],
            [x,y+1,z+1],
            // top
            [x+0,y+1,z+0],
            [x+1,y+1,z+0],
            [x+1,y+1,z+1],
            [x+0,y+1,z+0],
            [x+1,y+1,z+1],
            [x+0,y+1,z+1],
            // bottom
            [x+0,y,z+0],
            [x+1,y,z+0],
            [x+1,y,z+1],
            [x+0,y,z+0],
            [x+1,y,z+1],
            [x+0,y,z+1],
            // left
            [x,y+0,z+0],
            [x,y+1,z+0],
            [x,y+1,z+1],
            [x,y+0,z+0],
            [x,y+1,z+1],
            [x,y+0,z+1],
            // right
            [x+1,y+0,z+0],
            [x+1,y+1,z+0],
            [x+1,y+1,z+1],
            [x+1,y+0,z+0],
            [x+1,y+1,z+1],
            [x+1,y+0,z+1],
        ];*/    